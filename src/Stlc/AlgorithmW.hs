{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE InstanceSigs #-}

module Stlc.AlgorithmW where

-- This is a context-insensitive bottom-up approch to type checking
-- The pros are:
--     1. That most of the times, the algorithm is capable of
--        deriving the types of the expression if it is indeed well typed
--     2. It is decidable (for most of the cases) and
--         terminates in polynomial time
-- The cons are:
--     1. It terminates too late into the type checking process if the
--        term is ill-typed
--     2. Error messages generated by the algorithm are not
--        very easy to understand for the programmer.
--     3. Constraint solving and traversal of AST is combined
--        This makes it non-modular

-- References:
-- 1. Principle Type Schemes for Functional Programs
--    https://dl.acm.org/citation.cfm?id=582176
-- 2. http://dev.stephendiehl.com/fun/006_hindley_milner.html
-- 3. https://github.com/quchen/articles/tree/master/hindley-milner
-- 4. Proofs about a folklore let-polymorphic type inference algorithm
--    https://dl.acm.org/citation.cfm?id=291892

import Stlc.Language
import Stlc.Util

import Control.Applicative (liftA2)
import Control.Monad (liftM2)
import Control.Monad.State
import qualified Data.Map as Map
import Data.Map (Map)
import qualified Data.Set as Set
import Data.Set (Set)

import Debug.Trace (traceM)

-- Unify is a function that tries to unify 2 types or returns an error
-- The goal will be to convert left Type into a right Type
-- so that substitute t1 (unify (ty1, ty2)) = ty2 if unify returns a Right _
-- we need to update the state i.e. subs tcm and return a ()
unify :: Type ->  Type -> TCM ()
unify t1@(TArr a b) t2@(TArr c d) = StateT (\tcs -> do -- traceM ("DEBUG (unify t1 t2)\n\t" ++ show t1 ++ "\n\t" ++ show t2)
                                                    tcs' <- (execStateT $ unify a c) tcs
                                                    -- traceM ("DEBUG (unify a c): " ++  show tcs')
                                                    let s = subs tcs'
                                                    tcs'' <- (execStateT $ unify (substitute b s) (substitute d s)) tcs'
                                                    -- traceM ("DEBUG (unify b d): " ++  show tcs'')
                                                    return ((), tcs'')
                                        )
unify (TVar a) x@(TVar b)         | (a == b) = return ()
                                  | otherwise =  StateT (\tcs ->
                                                        return (()
                                                               , tcs {subs = (subs tcs) `mappend` (sub a x)}))
unify (TVar a) x          = do if (a `elem` fvs x)
                               then typeError
                                    $ "unification of "
                                    ++ (show a) ++ " and " ++ (show x)
                                    ++ " will lead to infinite type"
                               else StateT (\tcs ->
                                            return (()
                                                   ,tcs {subs = (subs tcs) `mappend` (sub a x)}))
unify x (TVar a)          = do if (a `elem` fvs x)
                               then typeError
                                    $ "unification of "
                                    ++ (show a) ++ " and " ++ (show x)
                                    ++ " will lead to infinite type"
                               else StateT (\tcs ->
                                            return (()
                                                   ,tcs {subs = (subs tcs) `mappend` (sub a x)}))
unify (TConst a) (TConst b) | (a == b)  = return ()
                            | otherwise = typeError
                                $ "Cannot unify "
                                  ++ (show a) ++ " and " ++ (show b)
unify (TConst a)  b         = typeError
                             $ "Cannot unify " ++ (show a)
                                ++ " with " ++ show b

unify a b                   = typeError $ "Cannot unify "
                                ++ (show a) ++ " and " ++ (show b)



-- Algorithm W should assign the most general type for the expression i.e.
-- it should generate a Principal Type Scheme when
-- given a context or should fail with an error
algoW :: Context -> Exp -> TCM (Type, Substitution)
-- Our Exp can be of 5 types EVar, ELit, ELam, EApp, ELet
-- so we simply patten match on each constructor type and start assigning
-- types
{-
   The first rule is for the literals,
   literals have a constant type. eg. True: Bool 0: Int
   and require no substitution

  -------------------------------------------[Lit]
               Γ ⊢ True : TBool

  -------------------------------------------[Lit]
               Γ ⊢ 3 : TInt

-}

algoW gamma (ELit x) = do case x of
                            LitB _ -> return $ (TConst TBool, mempty)
                            LitI _ -> return $ (TConst TInt, mempty)

{-
   The second rule is for the variable
      x : σ ϵ Γ            τ = instantiate(σ)
   -------------------------------------------[Var]
               Γ ⊢ x : τ

  search if the variable x exists in the context Γ and instantiate it.
  return an error if no such variable exists

-}

algoW gamma (EVar x) = do sig <- lookupVar gamma x              -- x : σ ϵ Γ
                          tau <- instantiate sig                -- τ = inst(σ)
                          return (tau, mempty)                  -- τ

{-
  This rule types lambda expression.
          Γ, x:T ⊢ e :T'
   -------------------------- [Lam]
       Γ ⊢ λx. e : T -> T'

  A new type variable is introduced that is bound to lambda and
  it is added on to the context Γ, the expression is then checked for
  its type and

-}
algoW gamma (ELam x e) = do x' <- fresh 'x'                             -- x:T
                            let gamma' =                                -- Γ, x:T
                                  updateContext gamma x (scheme x')
                            (ty, s) <- algoW gamma' e                   -- e: T'
                            return (TArr (substitute x' s) ty, s)        -- T -> T'

{-
   rule for application goes as follows:
   if we have an expression e e'
   then if the second expression e is well typed to T
   and the first expression should be of the form T -> T'
   then complete expression is of type T'


      Γ ⊢ e : T -> T'    Γ ⊢ e' :T
   --------------------------------------- [App]
                 Γ ⊢ e e' : T'


  The interesting bit here is we have to introduce a new
  type variable as the return type of the first expression
  and then fire unify to ensure the complete expression is well typed
-}
algoW gamma (EApp e e') = do (ty, s)  <- algoW gamma e         -- Γ ⊢ e : T -> T'
                             -- traceM ("e: " ++ show ty)
                             (ty', s') <- algoW (substitute gamma s) e'        -- Γ ⊢ e' :T
                             -- traceM ("e': " ++ show ty')
                             f <- fresh 'f'
                             unify (substitute ty s') (TArr ty' f)
                             s'' <- get
                             let subst = subs s''
                             -- traceM ("e e': " ++ show f)
                             return $ ((substitute f subst), (subst `mappend` s' `mappend` s))


{-
    Let bindings introduce variable names and associated types
    into the context Γ.

    The procedure for this rule is:
    - Obtain the type of e and bind it to x
    - then type check e' with the updated context

       Γ ⊢ e : T    sig = gen(Γ,T)    Γ, x: sig ⊢ e' :T'
   -------------------------------------------------------- [Let]
                  Γ ⊢ let x = e in e' : T'



-}
algoW gamma (ELet n e e') = do (ty, s) <- algoW gamma e                  -- Γ ⊢ e : T
                               let gamma' = substitute gamma s
                               sig <- generalize gamma' ty
                               let gamma'' = updateContext gamma' n sig  -- Γ, n: sig
                               (ty', s') <- algoW gamma'' e'             -- Γ, x: sig ⊢ e' :T'
                               return (ty', s `mappend` s')

algoW gamma (EFix f'@(EVar f) l@(ELam x e)) = do b <- fresh 'f'                                       --  new b
                                                 let gamma' = updateContext gamma f (scheme b)        --  gamma, f:b
                                                 (ty, s) <- algoW gamma' l
                                                 unify (substitute b s) ty
                                                 tcst <- get
                                                 let s' = subs tcst
                                                 return (substitute ty s', s `mappend` s')

algoW _ _  = typeError "Cannot infer type"
